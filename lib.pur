// make a vector
var list(x..) = x; 
vector vlist(vector x..) = x; 
//
vector split(vector v, int i) = [v[0:i], v[i:0]];   
vector range(n)={vector r=[];int i=-1;while (i+=1)<n:r<-i;r}; 
// a part of map
vector vmapref(vector L,int n)={vector s=[];int i= - 1, M=@L;while (i += 1)<M:s<-(L[i][n]);s};
var mapref(L,n)={vector s=[];int i= - 1, M=@L;while (i += 1)<M:s<-(L[i][n]);s};
vector vmapreg(vector L)={vector s=[];int i=-1,M=@L;while (i+=1)<M:s<-(L[i][1:0]);s};
// map
vector vmap1(var f(x),vector v)={vector s=[];int i=-1,M=@v;while (i+=1)<M:s<-f(v[i]);s}; 
var map1(var f(x),v)={var s=[];int i=-1,M=@v;while (i+=1)<M:s<-f(v[i]);s}; 
vector vmap(var f(x..),vector v..)={vector s=[];int i=-1,M=@v[0];while (i+=1)<M:s<-(apply(f,vmapref(v,i)));s};
var map(var f(x..), v..)={var s=[];int i=-1,M=@v[0];while (i+=1)<M:s<-(apply(f,vmapref(v,i)));s};

none vfor_each(var f(x..),vector v..)={int i=-1,M=@v[0];while (i+=1)<M:apply(f,vmapref(v,i));None};
none for_each(var f(x..), v..)={int i=-1,M=@v[0];while (i+=1)<M:apply(f,vmapref(v,i));None};

vector filter(int fn(x),vector v)={vector s=[];int i=-1,M=@v;while (i+=1)<M:if fn(v[i]):s<-v[i]:None;s};
vector partition(int fn(x),vector v)={vector s=[],t=[];int i=-1,M=@v;while (i+=1)<M:if fn(v[i]):s<-v[i]:t<-v[i];[s,t]};
vector vtabulate(int n,var f(x))={vector s=[];var i=-1;while (i+=1)<n:s<-f(i);s};

int irandn(int n)=irand()%n;
vector virand(int n)={vector r=[];while (n-=1)>=0:r<-irand();r};
vector virandn(int n,int m)={vector r=[];while (n-=1)>=0:r<-irandn(m);r};
vector vfrand(int n)={vector r=[];RANDMAX=2**63-1;while (n-=1)>=0:r<-(1.0*irand()/RANDMAX);r};

// vector marge(vector v1,vector v2)={int i=0,j=0,M1=@v1,M2=@v2;var d1,d2;vector r=[];while (i<M1)&&(j<M2):{if (d1=v1[i])>=(d2=v2[j]):{r<-d1;i+=1}:{r<-d2;j+=1}};if i==M1 :while j<M2:{r<-v2[j];j+=1}:while i<M1:{r<-v1[i];i+=1}; r};
// vector sort(vector v)={int n=@v,n2;n2=n/2;if n<=1:[v[0]]:if n==2:if v[0]>v[1]:v:[v[1],v[0]]:marge(sort(v[0:n2]),sort(v[n2:0]))};
 
vector marge(vector v1,vector v2)={
    int i=0,j=0,M1=@v1,M2=@v2;
    var d1,d2;
    vector r=[];
    while (i<M1)&&(j<M2):{
        if (d1=v1[i])>=(d2=v2[j]):
            {r<-d1;i+=1}
        :
            {r<-d2;j+=1}
    };
    if i==M1 :
        while j<M2:{
            r<-v2[j];
            j+=1
        }:
        while i<M1:{
            r<-v1[i];
            i+=1
        };
    r
};
vector sort(vector v)={
    int n=@v,n2;
    n2=n/2;
    if n<=1:
        [v[0]]:
    if n==2:
        if v[0]>v[1]:
            v
        :
            [v[1],v[0]]:
    marge(sort(v[:n2]),sort(v[n2:]))
};
 
// vector msort(vector v) = {
//     vector marge(vector v1,vector v2)={
//         int i=0,j=0,M1=@v1,M2=@v2;
//         var d1,d2;
//         vector r=[];
//         while (i<M1)&&(j<M2):{
//             if (d1=v1[i])>=(d2=v2[j]):
//                 {r<-d1;i+=1}
//             :
//                 {r<-d2;j+=1}
//         };
//         if i==M1 :
//             while j<M2:{
//                 r<-v2[j];
//                 j+=1
//             }:
//             while i<M1:{
//                 r<-v1[i];
//                 i+=1
//             };
//         r
//     };
//     vector sort(vector v)={
//         int n=@v,n2;
//         n2=n/2;
//         if n<=1:
//             [v[0]]:
//         if n==2:
//             if v[0]>v[1]:
//                 v
//	        :
//                 [v[1],v[0]]
//         :
//         marge(sort(v[0:n2]),sort(v[n2:0]))
//     };
//     sort(v) 
// }; 
none vfreverse(vector v)={int i=0,j=@v-1;while i<j:{vswap(v,i,j);i+=1;j-=1};None};
vector vreverse(vector v)={vector r=[];int i=@v;while (i-=1)>=0:r<-v[i];r};  /* test */ vreverse([1, 2, 3, 4, 5]); 

var fold1(var f(x,y),a,v)=if @v==0:a:fold1(f,f(a,v[0]),v[1:0]);

var fold_n(var f(x,y..),a,v..)={int i=-1,M=@v[0];while (i+=1)<M:a=apply(f,a,vmapref(v,i));a}; /* test */ fold_n(sum,0, [1,2,3,4,5],[5,4,3,2,1]);
int xor(int x,int y)=~(x&y) & (x|y);
vector range(int n,opt..)={vector v=[];int start=0,end=n,step=1;if @opt>=1:{start=n;end=opt[0]}:None;if @opt==2:step=opt[1]:None;if step>=0:while start<end:{v<-start;start+=step}:while start >end:{v<-start;start+=step};v};
vector iota(int n,opt..)={vector v=[];int start=0,step=1;if @opt>=1:start=opt[0]:None;if @opt==2:step=opt[1]:None;while (n-=1)>=0:{v<-start;start+=step};v};
//vector bsort(vector v)={int i=@v,j=0,j1;while i>=0:{j=0;while j<i-1:{j1=j+1;if v[j]<v[j1]:vswap(v,j,j1):None;j+=1};i-=1};v};//buble sort in place
vector bsort(vector v)={
	int i=@v,j=0,j1;
	while i>=0:{
		j=0;
		while j<i-1:{
			j1=j+1;
			if v[j]<v[j1]:
				vswap(v,j,j1)
			:
				None;
			j+=1
		};
		i-=1
	};
v};//buble sort in place
int fpartition(int f(x),vector v) = {int p=0,i=0;while i<@v:{if f(v[i]):{vswap(v,p,i);p+=1}:None;i+=1};p};//条件を満たすものを前半にそうでないものを後半に入れなおし、区切りのポイントを返す
//
vector fpartition3(var x,vector v)={int i,p,q,w;while i<@v:{w=cmp(v[i],x);if w<0:None:if w==0:{vswap(v,q,i);q+=1}:{vswap(v,p,i);vswap(v,q,i);p+=1;q+=1};i+=1};[p,q]};//partition3 in place
none qs(vector v)={vector ii;if @v<=1:None:if @v==2:if v[0]<v[1]:vswap(v,0,1):None:{ii=fpartition3(v[0],v);qs(v[:ii[0]]);qs(v[ii[1]:])}};//quick sort in place

//vector partition3(vector v)={vector p=[],q=[],r=[];int i=-1,M=@v,w1;var w;while (i+=1)<M:{w=v[i];w1=cmp(w,v[0]);if w1>0:p<-w:if w1==0:q<-w:r<-w};[p,q,r]};
//vector Qsort(vector v)={vector w;if @v<=1:v:{w=partition3(v);Qsort(w[0])+w[1]+Qsort(w[2])}};
vector partition3(vector v)={
	vector p=[],q=[],r=[];
	int i=-1,M=@v,w1;
	var w;
	while (i+=1)<M:{
		w=v[i];
		w1=cmp(w,v[0]);
		if w1>0:
			p<-w
		:if w1==0:
			q<-w
		:
			r<-w
	};
	[p,q,r]
};
vector Qsort(vector v)={
	vector w;
	if @v<=1:
		v
	:{
		w=partition3(v);
		Qsort(w[0])+w[1]+Qsort(w[2])
	}
};
int hi_part(int i)=i>>32;
int lo_part(int i)=i&0xFFFFFFFF;
int toint(x)=x;float tofloat(x)=x;long tolong(x)=x;lfloat tolfloat(x)=x;rational torat(x)=x;complex tocmplx(x)=x;var togeneral(x)=x;
//none downheap(vector v, int p) = {int n=@v,idx=p;int l_c=2*p+1,r_c=2*p+2;if l_c<n:if v[p]<v[l_c]:idx=l_c:None:None;if r_c<n:if v[idx]<v[r_c]:idx=r_c:None:None;if p != idx :{vswap(v,p,idx);downheap(v,idx)}:None};
//none heap_sort(vector v) = {int n=@v,i=@v/2;while (i-=1)>=0:downheap(v,i);while (n-=1)>0:{vswap(v,0,n);downheap(v[:n],0)}};
none downheap(vector v, int p) = {
	int n=@v,idx=p;
	int l_c=2*p+1,r_c=2*p+2;
	if l_c<n:
		if v[p]<v[l_c]:
			idx=l_c
	;
	if r_c<n:
		if v[idx]<v[r_c]:
			idx=r_c
	;
	if p != idx :{
		vswap(v,p,idx);downheap(v,idx)
	}
};
none heap_sort(vector v) = {
	int n=@v,i=@v/2;
	while (i-=1)>=0:
		downheap(v,i);
	while (n-=1)>0:{
		vswap(v,0,n);
		downheap(v[:n],0)
	}
};
//poly
//poly p = [c0, c1,..., cn] cn is coff of x^n
//var poly_value(vector p,var x)={int i=@p;var z=0;while (i-=1)>=0:z=z*x+p[i];z};
//vector poly_nornal(vector p) = {while p[-1]==0 && @p !=0 :vdel(p,-1;vmap(lambda(x) x/p[-1],p};
// chebyshev 
vector poly_add(vector v1,vector v2)={while @v1 > @v2:v2<-0/1;while @v1 <@v2:v1<-0/1;vmap(lambda(x,y) x+y,v1,v2)};
vector poly_s_mul(var x,vector v)=vmap(lambda(y) x*y,v);
//vector cheb(n)=if n==0:[1/1]:if n==1:[0/1,1/1]:vector_add(vector_s_mul(2,[0/1]+cheb(n-1)),vector_s_mul(-1,cheb(n-2)));
vector cheb(int n)={vector C(int n,vector a,vector b)=if n==0:b:C(n--,poly_add(poly_s_mul(2/1,[0/1]+a),poly_s_mul(-1/1,b)),a);C(n,[0/1,1/1],[1/1])};
vector hilbert(int n)={vector A=[];int i,j;for i=-1:(i+=1)<n:{A<-[];for j=-1:(j+=1)<n:A[-1]<-(1/(torat(i+j+1)))};A};
//
//string r2decstr(rational r,int size)={string s="";int i,L;if r>=0:None:{s="-";r=-r};s=s+str(tolong(r))+".";r=r-tolong(r);for i=0:i<size && r != 0:{L=toint(r*10);s=s+str(L);r=10*r-L;i+=1};s};
string r2decstr(rational r,int size)={
	string s="";
	int i,L;
	if r>=0:
		None:
	{
		s="-";
		r=-r
	};
	s=s+str(tolong(r))+".";
	r=r-tolong(r);
	for i=0:i<size && r != 0:
	{
		L=toint(r*10);
		s=s+str(L);
		r=10*r-L;
		i+=1
	};
	s
};
//vector factorint(long n)={vector v=[];int max;long q;if n<=2L**64:max=100000:max=1000000;while n>1L:{q=pollard_rho(n,2L,1L,max,10);if q !=0:{v<-q;n/=q}:n=1};v};
vector PRIME_LIST_20=filter(lambda(x) lis_prime(tolong(x))!=0,range(1,2**20));
vector trial_div(long n)={long p=n;vector V=[],v=[];while @(v=filter(lambda(x) p%tolong(x)==0,PRIME_LIST_20))!=0:{V=V+v;p/=tolong(fold1(lambda(x,y) x*y,1,v))};[V,p]};
string _msieve(long n) = popen("msieve -q "+str(n));
string _msieve_e(long n) = popen("msieve -q -e "+str(n));
vector msieve(long n)={string s;int p,q=0;vector v=[];s=_msieve(n);p=str_search(s,": ");if p<0:{v<-n;v}:{while p>=0:{s=s[p+2:];q=str_search(s,"\n");v<-tolong(s[:q]);p=str_search(s,": ")};v}};
vector msieve_e(long n)={string s;int p,q=0;vector v=[];s=_msieve(n);p=str_search(s,": ");if p<0:{v<-n;v}:{while p>=0:{s=s[p+2:];q=str_search(s,"\n");v<-tolong(s[:q]);p=str_search(s,": ")};v}};
var factorint(long n)={vector v=trial_div(n);if v[1] == 1:v[0]:v[0]+msieve_e(v[1])};

print("Library ver 0.01 loded.");