// make a vector
var list(x..) = x; 
vector vlist(vector x..) = x; 
//
vector split(vector v, int i) = [v[0:i], v[i:0]];   
vector range(n)={vector r=[];int i=-1;while (i+=1)<n:r<-i;r}; 
// a part of map
vector vmapref(vector L,int n)={vector s=[];int i= - 1, M=@L;while (i += 1)<M:s<-(L[i][n]);s};
var mapref(L,n)={vector s=[];int i= - 1, M=@L;while (i += 1)<M:s<-(L[i][n]);s};
vector vmapreg(vector L)={vector s=[];int i=-1,M=@L;while (i+=1)<M:s<-(L[i][1:0]);s};
// map
vector vmap1(var f(x),vector v)={vector s=[];int i=-1,M=@v;while (i+=1)<M:s<-f(v[i]);s}; 
var map1(var f(x),v)={var s=[];int i=-1,M=@v;while (i+=1)<M:s<-f(v[i]);s}; 
vector vmap(var f(x..),vector v..)={vector s=[];int i=-1,M=@v[0];while (i+=1)<M:s<-(apply(f,vmapref(v,i)));s};
var map(var f(x..), v..)={var s=[];int i=-1,M=@v[0];while (i+=1)<M:s<-(apply(f,vmapref(v,i)));s};

none vfor_each(var f(x..),vector v..)={int i=-1,M=@v[0];while (i+=1)<M:apply(f,vmapref(v,i));None};
none for_each(var f(x..), v..)={int i=-1,M=@v[0];while (i+=1)<M:apply(f,vmapref(v,i));None};

vector filter(int fn(x),vector v)={vector s=[];int i=-1,M=@v;while (i+=1)<M:if fn(v[i]):s<-v[i]:None;s};
vector partition(int fn(x),vector v)={vector s=[],t=[];int i=-1,M=@v;while (i+=1)<M:if fn(v[i]):s<-v[i]:t<-v[i];[s,t]};
vector vtabulate(int n,var f(x))={vector s=[];var i=-1;while (i+=1)<n:s<-f(i);s};

int irandn(int n)=irand()%n;
vector virand(int n)={vector r=[];while (n-=1)>=0:r<-irand();r};
vector virandn(int n,int m)={vector r=[];while (n-=1)>=0:r<-irandn(m);r};
vector vfrand(int n)={vector r=[];RANDMAX=2**63-1;while (n-=1)>=0:r<-(1.0*irand()/RANDMAX);r};

// vector marge(vector v1,vector v2)={int i=0,j=0,M1=@v1,M2=@v2;var d1,d2;vector r=[];while (i<M1)&&(j<M2):{if (d1=v1[i])>=(d2=v2[j]):{r<-d1;i+=1}:{r<-d2;j+=1}};if i==M1 :while j<M2:{r<-v2[j];j+=1}:while i<M1:{r<-v1[i];i+=1}; r};
// vector sort(vector v)={int n=@v,n2;n2=n/2;if n<=1:[v[0]]:if n==2:if v[0]>v[1]:v:[v[1],v[0]]:marge(sort(v[0:n2]),sort(v[n2:0]))};
 
vector marge(vector v1,vector v2)={
    int i=0,j=0,M1=@v1,M2=@v2;
    var d1,d2;
    vector r=[];
    while (i<M1)&&(j<M2):{
        if (d1=v1[i])>=(d2=v2[j]):
            {r<-d1;i+=1}
        :
            {r<-d2;j+=1}
    };
    if i==M1 :
        while j<M2:{
            r<-v2[j];
            j+=1
        }:
        while i<M1:{
            r<-v1[i];
            i+=1
        };
    r
};
vector sort(vector v)={
    int n=@v,n2;
    n2=n/2;
    if n<=1:
        [v[0]]:
    if n==2:
        if v[0]>v[1]:
            v
        :
            [v[1],v[0]]:
    marge(sort(v[:n2]),sort(v[n2:]))
};
 
// vector msort(vector v) = {
//     vector marge(vector v1,vector v2)={
//         int i=0,j=0,M1=@v1,M2=@v2;
//         var d1,d2;
//         vector r=[];
//         while (i<M1)&&(j<M2):{
//             if (d1=v1[i])>=(d2=v2[j]):
//                 {r<-d1;i+=1}
//             :
//                 {r<-d2;j+=1}
//         };
//         if i==M1 :
//             while j<M2:{
//                 r<-v2[j];
//                 j+=1
//             }:
//             while i<M1:{
//                 r<-v1[i];
//                 i+=1
//             };
//         r
//     };
//     vector sort(vector v)={
//         int n=@v,n2;
//         n2=n/2;
//         if n<=1:
//             [v[0]]:
//         if n==2:
//             if v[0]>v[1]:
//                 v
//	        :
//                 [v[1],v[0]]
//         :
//         marge(sort(v[0:n2]),sort(v[n2:0]))
//     };
//     sort(v) 
// }; 
none vfreverse(vector v)={int i=0,j=@v-1;while i<j:{vswap(v,i,j);i+=1;j-=1};None};
vector vreverse(vector v)={vector r=[];int i=@v;while (i-=1)>=0:r<-v[i];r};  /* test */ vreverse([1, 2, 3, 4, 5]); 

var fold1(var f(x,y),a,v)=if @v==0:a:fold1(f,f(a,v[0]),v[1:0]);

var fold_n(var f(x,y..),a,v..)={int i=-1,M=@v[0];while (i+=1)<M:a=apply(f,a,vmapref(v,i));a}; /* test */ fold_n(sum,0, [1,2,3,4,5],[5,4,3,2,1]);
int xor(int x,int y)=~(x&y) & (x|y);
vector range(int n,opt..)={vector v=[];int start=0,end=n,step=1;if @opt>=1:{start=n;end=opt[0]}:None;if @opt==2:step=opt[1]:None;if step>=0:while start<end:{v<-start;start+=step}:while start >end:{v<-start;start+=step};v};
vector iota(int n,opt..)={vector v=[];int start=0,step=1;if @opt>=1:start=opt[0]:None;if @opt==2:step=opt[1]:None;while (n-=1)>=0:{v<-start;start+=step};v};
vector bsort(vector v)={int i=@v,j=0,j1;while i>=0:{j=0;while j<i-1:{j1=j+1;if v[j]<v[j1]:vswap(v,j,j1):None;j+=1};i-=1};v};//buble sort in place
int fpartition(int f(x),vector v) = {int p=0,i=0;while i<@v:{if f(v[i]):{vswap(v,p,i);p+=1}:None;i+=1};p};//条件を満たすものを前半にそうでないものを後半に入れなおし、区切りのポイントを返す
//
vector fpartition3(var x,vector v)={int i,p,q,w;while i<@v:{w=cmp(v[i],x);if w<0:None:if w==0:{vswap(v,q,i);q+=1}:{vswap(v,p,i);vswap(v,q,i);p+=1;q+=1};i+=1};[p,q]};//partition3 in place
none qs(vector v)={vector ii;if @v<=1:None:if @v==2:if v[0]<v[1]:vswap(v,0,1):None:{ii=fpartition3(v[0],v);qs(v[:ii[0]]);qs(v[ii[1]:])}};//quick sort in place

vector partition3(vector v)={vector p=[],q=[],r=[];int i=-1,M=@v,w1;var w;while (i+=1)<M:{w=v[i];w1=cmp(w,v[0]);if w1>0:p<-w:if w1==0:q<-w:r<-w};[p,q,r]};
vector Qsort(vector v)={vector w;if @v<=1:v:{w=partition3(v);Qsort(w[0])+w[1]+Qsort(w[2])}};
int hi_part(int i)=i>>32;
int lo_part(int i)=i&0xFFFFFFFF;

